Gitlet Design Document
----------------------


Classes and Data Structures
---------------------------
- Repo class
    - staging area directory
        - file that represents added staging area things
            - for each file that needs to be added, it should be a new file made of the file name that needs to be added
            - and it's file contents which are the blobs
        - file that represents removed staging area things - could be a list of file names
    - tracked/untracked files director\

    - head - will be a commit that is most recent
    - branches - can be represented by the most current commit of these branches (list of commits)
        - branches are new when you split off a new commit

    - instance variable branches
        - lists the names of the branches

    - this is where all the commands are - because you need to access everything in the repo to edit it

    - instance variables
        - make a list of the branches
        - have a staging area hashmap
        - have an untracked files list/array

    - methods
        - constructor() - takes in nothing
            - this will be where you make the directory, make the initial empty/null commit
                - make a staging area file and commits file
                - every time you make a commit, add it to the commits folder by making a file called it's SHA-id
                - this way you have it all saved somewhere
                    - the contents of this file should be the serialized commit
            - remember that you need a hashmap to keep track of commits/files/edits
                - do this by saving the branches as a hashmap of head commits - get the head, map it to it's proper commit
            - make the staging area and untracked filed empty hasmas and array lists, respectively (of strings)
        - method init
            - this makes a new directory .gitlet in the repo
                - use makeDir to do this
                - should make a new repo too
                    - branches will be just master, pointing to the empty commit
            - automatically starts with an empty commit
                - make a new commit of no files/blobs, just a message, time, location, etc
            - check if a directory already exists - do this by looking for a directory called .gitlet that
                - already exists
        //these methods don't necessarily need to be written in the order they appear//
        - method add
            - should take in the file name
            - add(string fileName)
                - need to make sure this file exists (google documentation for this method)
                - print out error message and exit without doing anything else
            - 1) make a file newFile(file name, blob) - where blob is the copy of the file contents
            - 2) get the blob saves for this same file name from the commit (hashMap that keeps track of all of this)
                - check the current commit
            - 3) if the blobs (compared from step 2) are the same, do nothing
            - 4) if not, add the newFile(file name, blob) to the staging area
            - on adding the file from Piazza:
                -  "We can use new File(...) but that will not be enough. When you're copying a file,
                you must create a new File object in Java and get the contents of the file you're trying
                to copy and write the contents so that the file persists on disk. I highly recommend looking
                 over the methods readContents and writeContents in Utils. Specifically what name you want
                 to give to the copy is up to your design but it would be helpful to have it be dependent
                 on the content of the file."
                - "You know first not to stage a file that already exists in the same state in the current commit.
                 So if I have a.txt which contains "hello", then I add it and commit it, if I then add it again after
                 making that first commit, it will not go into the staging area because the content - "hello" - is
                 unchanged. Okay, so now let's change it. I change a.txt to "hello!" then add it. Now a.txt is in
                 the staging area. Finally, let's say I change my mind and manually change a.txt back to "hello"
                 (by editing it not using checkout), then add it again. Now we remove it from the staging area,
                 because a.txt is exactly the same as it was in the current commit. Basically because it is possible
                 to change a blob (change its content then change it back) but not want to add it, make sure you are
                 keep track of changes in files based on their actual content, not just the fact that they have been
                 edited."
                    - here is where you'll probably check the SHA-id of blobs


        - method commit
            - "saves snapshot of certain files in the commit and staging area so they can be
             restored later"
            - look at the files in the staging area - for each of the files in here, put them
            in the tracked files
            - now the new commit needs to be this one - commit now contains the version of the file
            it got from its parent
            - will save and track any files that were staged but NOT tracked by the parent
            - files tracked in the current commit are now untracked in the next commit - make the next
            commit's tracked/staging area empty
            - other notes
                - doesn't change files in the working directory, only what's in the .gitlet directory
                    - add to the commits file
            - head pointer now points to this commit
            - previous head pointer is this commit's parent (remember this when making a new commit)
                - will come with a message that will also go into making this new commit
            - SHA-id of the commit will include the file (blob) references of its files, parent ref, log message.
            commit time
            - failure cases:
                - no files have been staged (is the staging area empty)
                - no commit message (check args)
        - method rm
            - unstage the file if it's currently staged (look at staging area)
            - if it is marked tracked by the current commit, mark to indicate it won't be included in the next commit
                - store this somewhere in the .gitlet directory (tracking area)
            - remove this from the working directory if not done already - do not remove unless tracked in the current commit
            - failure cases
                - if it's not staged or tracked by the head commit, give an error
        - method log
            - STARTING at the head commit, display info about each commit backwards until at the initial commit
                - you'll know this once this one doesn't have a head or maybe set some instance variable if it's
                the first commit (some boolean first = false/true for each commit, first would be true, everything else
                is false)


            need to alter the head and the master
            - connect your blob to the commit
        - method

- Commit class
    - instance variable for time
    - instance variable for location
    - instance variable for the message
    - instance variable for blobs in the commit
    - instance variable ID for SHA-id - make it in the constructor
        - SHA-id should be made of the blobs in the commit, nothing else
    - instance variable for hashMap of blobs to the file name
        - every time you add, edit this hashmap that you'll use to make the commit
        - My current plan is to completely copy over the parent commit's hashmap of files (blobs) into my new commit,
         then update the values of the keys according the contents in the staging area.
            - this is how you update the hash map for the commit

    - constructor(time, location, message, blobs, ID)
    - method to grab the time
    - method to grab the location
    - method to grab the message
        - these will be used in the log method
    - method to grab the blobs
    - method to grab the SHA ID
- Main class
    - at the beginning, you will need to parse through the args they give you to figure out what they're trying to ask
    - make sure the command is valid

MAIN SKELETON CODE

/**At the beginning, check to make sure whatever command is inputted is valid.  Grab args[0] as the command.*/
(not a method, just a try catch exception)
    //also check if the repo exists so far.  Make a function later to check for this.
    //use this repo (make another function to save the repo contents and return them) to make the calls on
    //depending on what the command is, call it on the repo with the appropriate arguments too
/**Check if repo exists.*/
boolean checkRepo() { //check if the directory has a repo. }
/**Save contents of the repo to use later.*/
void saveRepo() { //save repo }
/**Return the repo.*/
Repo returnRepo() { //return the repo. }
/**Repo you will be using.*/
Repo theRepo;
/**Command that is inputted.*/
String command;
/**follow up arguments.*/
String followUpArgs;
/**Boolean that tells if the repo exists.*/
Boolean repoExists;

REPO CLASS SKELETON CODE
/**Constructor method.*/
Repo Repo() {}
- create a bunch of instance variables + initialize them
/**Staging area adding/removing.*/
~~~~make this a directory~~~~~
ArrayList<String> _adding; //staging area with what to add - try file names
ArrayList<String> _removing; //what needs to be removed - file names
~~~~make this a directory too~~~~
/**Tracked files. Should be another directory in the repo with a bunch of names of file in it.*/
Directory???? trackedFiles;
/**Most recent commit, called the head.*/
    //make this also a directory thing with the actual serialized commit in it!
/**Master branch, initially points to the initial commit, then to the current branch after that.
The default initial branch.*/
String _master;
/**Branches represented by the most recent commit of each brance.*/
ArrayList<String> _branches;  //every time you make a new branch/commit, this also needs to be changed - should be SHA-ids
/**Tree of the commit's sha-ids.*/
Tree <String> _commitTree;
/**The add method adds a copy of the file as it exists to the staging area.*/
void add(String fileName) {
    - need to first make sure this fileName exists (google the documentation to check for this)
        - if it doesn't exist, print out the error message
    - 1) make a file newFile(fileName, blob), where the blob is the copy of the file contents (see: Utils)
        - "We can use new File(...) but that will not be enough. When you're copying a file,
         you must create a new File object in Java and get the contents of the file you're trying
         to copy and write the contents so that the file persists on disk. I highly recommend looking
         over the methods readContents and writeContents in Utils. Specifically what name you want
         to give to the copy is up to your design but it would be helpful to have it be dependent
         on the content of the file."
    - 2) get the blob from the current commit hashMap that should be tracking all of this - could be a hashMap of SHA
    -id's of these blobs or just using the byte arrays?
    - 3) check and compare the blob from 2) and 1). If they are the same, do nothing.
    - 4) If they are different, add the newFile(fileName, blob) to the staging area
    - hint from Piazza: "You know first not to stage a file that already exists in the same state in the current commit.
                     So if I have a.txt which contains "hello", then I add it and commit it, if I then add it again after
                     making that first commit, it will not go into the staging area because the content - "hello" - is
                     unchanged. Okay, so now let's change it. I change a.txt to "hello!" then add it. Now a.txt is in
                     the staging area. Finally, let's say I change my mind and manually change a.txt back to "hello"
                     (by editing it not using checkout), then add it again. Now we remove it from the staging area,
                     because a.txt is exactly the same as it was in the current commit. Basically because it is possible
                     to change a blob (change its content then change it back) but not want to add it, make sure you are
                     keep track of changes in files based on their actual content, not just the fact that they have been
                     edited."
                        - here is where you'll probably check the SHA-id of blobs
    }
/**commit method.*/
void commit(String message) {
    - create a new commit - using the message, time, etc, serialize it
    - add it to the commit directory by using something like the following:
        -   public void saveDog() {
                  capers.Utils.writeObject(capers.Utils.join(DOG_FOLDER, this._name), this);
              }
        where
        -    static void writeObject(File file, Serializable obj) {
                  writeContents(file, serialize(obj));
              }
    - should only deal with whatever is in the staging area, nothing else - it's hash map will now differ from
    its parent (how much?)
    - this new commit will be made with the blob and file from the staging area
    - update the hashmap by copying the one from before and updating it to match what's in the
    staging area
    - change the master and head instance variables of the repo (thisRepo._master = new SHA-id, etc)
        - this commit's parent is the previous head commit
    - will save and start tracking which files are staged but not tracked by the parent
    - any files tracked in the current commit can become untracked in the new commit BECAUSE of the rm command
    - clear the staging area
    - does not affect the working directory (that's rm)
    - new commit should be added to the commit tree (make this in repo? with SHA-id's?)
    - failure cases to take care of:
        - if no files have been staged/marked for untracking print "No changes added to the commit."
        - it is NOT a failure if the tracked file doesn't exist in the working directory, ignore everything
        outside of the .gitlet directory
}
/**rm method.*/
void rm(String fileName) {
    - unstage the specified file - only that one file
    - if it's tracked in this commit, don't add it in the next commit by marking it as so (somewhere in the
    .gitlet directory) - maybe have a staging area and tracked files directories in the repo
    - remove the file from the working directory if the user has not already done so - do not remove
    it unless it's tracked in the current commit
    - failure cases: if the file is neither staged nor tracked by the HEAD commit - print the error
    message "No reason to remove the file."
}
/**log method. Starting at the head commit, display information about each commit backwards until you hit
the initial commit, following the first parent commit links, ignoring any second parents from merge commits.*/
void log() {
    - access the head commit from the head directory. deserialize this and print out it's info
    - so this for the parent commit of the head commit
    - use a while loop until parent commit == null
    - look at merge to figure out what to do when there is a merge commit and two parents
    - look at spec for the format of the printing out
        - there is a === before each commit and an empty line after it
        - each entry displays the SHA-id of the commit too
        - timestamps should reflect the commit time in the current timezone (see Time class)
    - use System.out.println and the get methods in the Commit object class
    - Java classes java.util.Date and java.util.Formatter will be useful
    - for merge commits (when there are two parents) add a line below the commit that says
        "Merge developed into master."
}
/**global-log method.*/

/**find method.*/
/**status method.*/
/**checkout method.*/
- three diff types of checkout that it needs to look out for
/**branch method.*/
/**rm-branch method.*/
/**reset method.*/
/**merge method.*/


COMMIT CLASS SKELETON CODE
 **commit should implement serializable*
/**Need an init to make a commit.*/
Commit(String message, String time, String location, boolean isFirst)
- message will be the commit message
- time will be the time
- location is the location
- isFirst is true only for the first initial commit (because this will be traced back to for the rest of the commits
    in the project
/**Instance variables.*/
String _message;
String _time;
String _location;
boolean _isFirst;
HashMap _blobs;
    - this will contain nothing at first and in the future will be copy's of the parent's commit's hash map
    plus whatever is new in the staging area - so read the staging area and add it to the next commit
Commit parent;
    - SHA-id of the commit before it
/**Return the message.*/
String returnMessage()
/**Return the time.*/
String returnTime()
/**Return the location.*/
String returnLocation()
/**Return the boolean _isFirst.*/
boolean returnIsFirst()
/**Return the hashMap _blobs.*/
hashMap returnBlobs()
/**Return the SHA-id.*/
String returnId()
/**Return the parent commit.*/
commit returnParent()

ADD method (in repo) skeleton code





Algorithms
----------

Persistence
-----------

Other Concepts
----------
- blobs
    - blobs are essentially copies of the files you're trying to add
    - this means, to make them, make them a copy of the file you're trying to add by using what is in the utils
    - give it a unique SHA-id (?) possibly